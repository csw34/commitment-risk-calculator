<script>
      // --- Original Calculator Logic ---
      const fmtCurrency = (n) =>
        n == null
          ? 'â€”'
          : n.toLocaleString(undefined, {
              style: 'currency',
              currency: 'USD',
              maximumFractionDigits: 0,
            });

      const el = {
        monthlyUsage: document.getElementById('monthlyUsage'),
        maxCoverage: document.getElementById('maxCoverage'),
        maxCoverageNum: document.getElementById('maxCoverageNum'),
        threeYrPortion: document.getElementById('threeYrPortion'),
        threeYrPortionNum: document.getElementById('threeYrPortionNum'),
        disc1: document.getElementById('disc1'),
        disc3: document.getElementById('disc3'),
        dur1: document.getElementById('dur1'),
        dur3: document.getElementById('dur3'),
        kpiMonthlyCommit: document.getElementById('kpiMonthlyCommit'),
        kpiOutstanding: document.getElementById('kpiOutstanding'),
        kpiBreakeven: document.getElementById('kpiBreakeven'),
        csvFileInput: document.getElementById('csvFileInput'),
        chartContainer: document.getElementById('chartContainer'),
      };

      function calcTotalMonthlyCommitment({
        monthlyUsage,
        maxCoverageTarget,
        disc1,
        disc3,
        threeYrPct,
      }) {
        const threeYrPortion = threeYrPct / 100;
        const oneYrPortion = 1 - threeYrPortion;
        const coverage = maxCoverageTarget / 100;
        return (
          monthlyUsage * coverage * (1 - disc1 / 100) * oneYrPortion +
          monthlyUsage * coverage * (1 - disc3 / 100) * threeYrPortion
        );
      }

      function calcTotalOutstanding({
        totalMonthlyCommit,
        dur1,
        dur3,
        threeYrPct,
      }) {
        const threeYrPortion = threeYrPct / 100;
        const oneYrPortion = 1 - threeYrPortion;
        return (
          totalMonthlyCommit * (dur1 * oneYrPortion + dur3 * threeYrPortion)
        );
      }

      function calcBreakeven({ disc1, disc3, threeYrPct, dur1, dur3 }) {
        const threeYrPortion = threeYrPct / 100;
        const oneYrPortion = 1 - threeYrPortion;
        return (
          (1 - disc1 / 100) * oneYrPortion * dur1 +
          (1 - disc3 / 100) * threeYrPortion * dur3
        );
      }

      function syncSliders(rangeEl, numberEl, updateFn) {
        rangeEl.addEventListener('input', () => {
          numberEl.value = rangeEl.value;
          updateFn();
        });
        numberEl.addEventListener('input', () => {
          let val = Number(numberEl.value);
          if (isNaN(val)) val = 0;
          val = Math.max(0, Math.min(100, val));
          rangeEl.value = val;
          numberEl.value = val;
          updateFn();
        });
      }

      function update() {
        const monthlyUsage = Number(el.monthlyUsage.value) || 0;
        const maxCoverageTarget = Number(el.maxCoverageNum.value) || 0;
        const threeYrPct = Number(el.threeYrPortionNum.value) || 0;
        const disc1 = Number(el.disc1.value) || 0;
        const disc3 = Number(el.disc3.value) || 0;
        const dur1 = Number(el.dur1.value) || 0;
        const dur3 = Number(el.dur3.value) || 0;

        const totalMonthlyCommit = calcTotalMonthlyCommitment({
          monthlyUsage,
          maxCoverageTarget,
          disc1,
          disc3,
          threeYrPct,
        });
        const totalOutstanding = calcTotalOutstanding({
          totalMonthlyCommit,
          dur1,
          dur3,
          threeYrPct,
        });
        const breakeven = calcBreakeven({
          disc1,
          disc3,
          threeYrPct,
          dur1,
          dur3,
        });

        el.kpiMonthlyCommit.textContent = fmtCurrency(totalMonthlyCommit);
        el.kpiOutstanding.textContent = fmtCurrency(totalOutstanding);
        el.kpiBreakeven.textContent = breakeven.toFixed(2) + ' months';
      }

      syncSliders(el.maxCoverage, el.maxCoverageNum, update);
      syncSliders(el.threeYrPortion, el.threeYrPortionNum, update);
      ['monthlyUsage', 'disc1', 'disc3', 'dur1', 'dur3'].forEach((id) => {
        el[id].addEventListener('input', update);
      });

      // --- New CSV and Charting Logic ---

      let commitmentChartInstance = null;
      const MS_PER_DAY = 1000 * 60 * 60 * 24;

      // Listen for file upload
      el.csvFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) {
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const text = e.target.result;
          try {
            const data = parseCSV(text);
            const chartData = calculateOutstandingOverTime(data);
            renderChart(chartData);
            el.chartContainer.style.display = 'block';
          } catch (error) {
            console.error('Error processing CSV:', error);
            alert(
              'Failed to parse CSV. Check console for details. Make sure it has the expected headers.'
            );
          }
        };
        reader.readAsText(file);
      });

      /**
       * Parses CSV text into an array of objects.
       * Assumes the first row is the header.
       */
      function parseCSV(text) {
        const lines = text.trim().split('\n');
        const headers = lines[0].split(',').map((h) => h.trim());
        const data = [];

        // Find required column indices
        const stateIndex = headers.indexOf('State');
        const priceIndex = headers.indexOf('Active Commitment'); // CHANGED from 'Commitment Fee'
        const endIndex = headers.indexOf('End Time');

        if (stateIndex === -1 || priceIndex === -1 || endIndex === -1) {
          throw new Error(
            'CSV must contain "State", "Active Commitment", and "End Time" columns.' // UPDATED error message
          );
        }

        for (let i = 1; i < lines.length; i++) {
          const values = lines[i].split(',');
          if (values.length >= headers.length) { // Use >= to be more robust against trailing commas
            data.push({
              State: values[stateIndex].trim(),
              Price: parseFloat(values[priceIndex]), // CHANGED from CommitmentFee, "0.01 $/hr" -> 0.01
              EndTime: new Date(values[endIndex].trim()), // "2026-09-15"
            });
          }
        }
        return data;
      }

      /**
       * Calculates the total outstanding commitment for each day
       * from today until the last commitment expires.
       */
      function calculateOutstandingOverTime(data) {
        const activeCommitments = data.filter(
          (row) => row.State === 'Active' && !isNaN(row.EndTime.getTime())
        );

        if (activeCommitments.length === 0) {
          return { labels: [], data: [] };
        }

        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // Find the last expiration date
        const maxEndDate = new Date(
          Math.max(...activeCommitments.map((row) => row.EndTime.getTime()))
        );

        const labels = [];
        const dataPoints = [];

        // Loop from today until the last CUD expires
        for (
          let d = new Date(today.getTime());
          d <= maxEndDate;
          d.setDate(d.getDate() + 1)
        ) {
          let totalOutstandingForDate = 0;
          const currentDate = new Date(d.getTime());

          for (const commit of activeCommitments) {
            if (commit.EndTime > currentDate) {
              // Calculate remaining days
              const diffTime = commit.EndTime.getTime() - currentDate.getTime();
              const diffDays = Math.ceil(diffTime / MS_PER_DAY);
              
              // Formula: (hourly rate) * (days) * (24 hr/day)
              totalOutstandingForDate += commit.Price * diffDays * 24; // CHANGED from commit.CommitmentFee
            }
          }

          labels.push(new Date(currentDate.getTime())); // Store as a new Date object
          dataPoints.push(totalOutstandingForDate);
        }

        return { labels, data: dataPoints };
      }

      /**
       * Renders the line chart using Chart.js
       */
      function renderChart({ labels, data }) {
        if (commitmentChartInstance) {
          commitmentChartInstance.destroy();
        }

        const ctx = document.getElementById('commitmentChart').getContext('2d');
        commitmentChartInstance = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Remaining Commitment Outstanding',
                data: data,
                borderColor: 'rgb(79, 70, 229)',
                backgroundColor: 'rgba(79, 70, 229, 0.1)',
                fill: true,
                tension: 0.1,
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'month',
                  tooltipFormat: 'MM/dd/yyyy',
                },
                title: {
                  display: true,
                  text: 'Date',
                },
              },
              y: {
                title: {
                  display: true,
                  text: 'Outstanding Commitment ($)',
                },
                ticks: {
                  callback: (value) => fmtCurrency(value),
                },
              },
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: (context) =>
                    `Outstanding: ${fmtCurrency(context.parsed.y)}`,
                },
              },
            },
          },
        });
      }

      // Initial calculation for the hypothetical calculator
      update();
    </script>
